package compile

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	cfg "github.com/gascore/gas/gasx/cmd/config"
	"github.com/gascore/gas/gasx/cmd/lock"
	"github.com/gascore/gas/gasx/utils"
	"github.com/spf13/cobra"
	"golang.org/x/net/html"
)

/*
	Never try to understand this parser
	Ребята не стоит вскрывать этот код. Вы молодые, шутливые, вам все легко...
*/

func Return() *cobra.Command {
	var cmdCompile = &cobra.Command{
		Use:   "compile [flags]",
		Short: "Compile all .gas files",
		Run: func(cmd *cobra.Command, args []string) {
			allConfig, err := cfg.ParseConfig()
			utils.Must(err)

			gasLock, buildExternal, err := lock.ParseGasLock(allConfig)
			utils.Must(err)

			utils.Must(Body(allConfig, gasLock, buildExternal))

			utils.Must(gasLock.Save())
		},
	}

	return cmdCompile
}

type File struct {
	Path       string
	IsExternal bool
}

func Body(allConfig *cfg.Config, gasLock *lock.Lock, buildExternal bool) error {
	config := allConfig.Compile

	currentDir, err := os.Getwd()

	goFile := os.Getenv("GOFILE")

	templates, err := GetGasFiles(currentDir, buildExternal, allConfig)
	if err != nil {
		return err
	}

	var styles = make(map[string]string)
	for _, file := range templates {
		style, err := parseFile(file, goFile, config)
		if err != nil {
			return err
		}

		if len(style) != 0 {
			styles[file.Path] = style
		}
	}

	if !config.SupportStyles {
		return nil
	}

	err = genStyles(styles, config, gasLock, currentDir, buildExternal)
	if err != nil {
		return err
	}

	return nil
}

func genStyles(styles map[string]string, config cfg.Compile, gasLock *lock.Lock, currentDir string, buildExternal bool) error {
	var mainCss string
	externalStyles := make(map[string]string)

	if !buildExternal && gasLock.Styles != nil {
		for key, value := range gasLock.Styles {
			styles[key] = value
		}
	}

	for name, value := range styles {
		style := fmt.Sprintf("/*=== Styles from %s ===*/\n%s\n", strings.TrimPrefix(name, currentDir+"/"), value)
		mainCss = mainCss + style

		if buildExternal && strings.Index(name, currentDir) == -1 {
			externalStyles[name] = value
		}
	}

	if buildExternal { // save for ignoring
		gasLock.Styles = externalStyles
	}

	mainCssFile, err := os.Create(config.StylesOut)
	if err != nil {
		return err
	}

	_, err = mainCssFile.WriteString(mainCss)
	if err != nil {
		return err
	}

	return mainCssFile.Close()
}

func parseFile(fileInfo File, gofile string, config cfg.Compile) (string, error) {
	filePathWS := strings.TrimSuffix(fileInfo.Path, ".gas")
	fileBase := strings.TrimSuffix(filepath.Base(fileInfo.Path), ".gas")

	var suffix string
	if fileInfo.IsExternal {
		suffix = config.ExternalFilesSuffix
	} else {
		suffix = config.FilesSuffix
	}

	filename := filePathWS + suffix + ".go"

	// Prevent overwriting the file calling gasx via go generate.
	if filename == gofile {
		return "", fmt.Errorf("file conflict on name: %s", filename)
	}

	// Open the .gas file.
	fileBytes, err := ioutil.ReadFile(fileInfo.Path)
	if err != nil {
		return "", err
	}

	// Read and .gas file.
	buf := bytes.NewBuffer(fileBytes)

	// Parse the .gas file file into html nodes.
	nodes, err := Parse(buf)
	if err != nil {
		return "", err
	}

	templateRaw, fileTags, err := ParseTemplate(filepath.Dir(fileInfo.Path), nodes)
	if err != nil {
		return "", err
	}

	script := fileTags["script"]

	buf.Reset()
	err = html.Render(buf, FirstChild(templateRaw))
	if err != nil {
		return "", err
	}

	parsedNode, err := parseNode(buf.String())
	if err != nil {
		return "", err
	}

	template, err := executeEl(parsedNode, true)
	if err != nil {
		return "", err
	}

	// Write the source as a Go file.
	osFile, err := os.Create(filename)
	if err != nil {
		return "", err
	}

	varName := fileBase + "T"
	varI := strings.Index(script, varName)
	if varI == -1 {
		return "", fmt.Errorf("no \"%s\" in file \"%s\"", varName, fileInfo.Path)
	}

	script = script[:varI] + template + script[varI+len(varName):] // replace varName to parsedTemplate

	_, err = osFile.WriteString(fmt.Sprintf("// Code generated by gasx. DO NOT EDIT.\n// source: %s.gas\n\n", fileBase))
	if err != nil {
		return "", err
	}

	_, err = osFile.WriteString(script)
	if err != nil {
		return "", err
	}

	err = osFile.Close()
	if err != nil {
		return "", err
	}

	style := fileTags["style"]
	if config.SupportStyles && style != "" {
		return style, nil
	}

	return "", nil
}
